<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Dreamland</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    :root {
      --gb0: #0f380f;
      --gb1: #306230;
      --gb2: #8bac0f;
      --gb3: #9bbc0f;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #0a0a0a;
      color: var(--gb3);
      font-family: 'Press Start 2P', monospace;
      overflow: hidden;
      width: 100vw; height: 100vh;
      display: flex; align-items: center; justify-content: center;
      image-rendering: pixelated;
    }

    #game-wrapper {
      position: relative; width: 100%; max-width: 960px;
      aspect-ratio: 16/10; max-height: 100vh;
      background: var(--gb0); overflow: hidden;
      border: 4px solid var(--gb1);
      box-shadow: 0 0 60px rgba(155,188,15,0.08), inset 0 0 80px rgba(0,0,0,0.4);
    }

    #game-wrapper::after {
      content: ''; position: absolute; inset: 0; pointer-events: none; z-index: 999;
      background: repeating-linear-gradient(0deg, transparent 0px, transparent 2px, rgba(0,0,0,0.05) 2px, rgba(0,0,0,0.05) 4px);
      mix-blend-mode: multiply;
    }

    #phaser-canvas { width: 100%; height: 100%; display: block; }
    #phaser-canvas canvas { width: 100% !important; height: 100% !important; }

    #ui-overlay {
      position: absolute; inset: 0; pointer-events: none;
      display: flex; flex-direction: column; justify-content: flex-end; z-index: 10;
    }

    #hud {
      position: absolute; top: 0; left: 0; right: 0;
      display: flex; justify-content: space-between; align-items: center;
      padding: 6px 10px; background: var(--gb0);
      border-bottom: 2px solid var(--gb1); font-size: 10px; z-index: 20;
    }
    #hud-age { font-size: 12px; color: var(--gb3); }
    #hud-meta { color: var(--gb2); font-size: 7px; text-align: right; max-width: 50%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

    #hud-relations {
      position: absolute; top: 28px; right: 6px;
      display: flex; flex-direction: column; gap: 4px; z-index: 20;
    }
    .rel-chip {
      display: flex; align-items: center; gap: 6px;
      background: var(--gb0); border: 2px solid var(--gb1);
      padding: 3px 8px 3px 3px; font-size: 7px; color: var(--gb2);
      min-width: 100px;
    }
    .rel-chip .rel-name { display: block; color: var(--gb3); font-size: 7px; line-height: 1.2; }
    .rel-chip .rel-role { display: block; color: var(--gb2); font-size: 5.5px; opacity: 0.8; margin-top: 1px; }
    .rel-icon { width: 28px; height: 28px; border: 2px solid var(--gb1); image-rendering: pixelated; flex-shrink: 0; }

    #dialogue-area { pointer-events: auto; padding: 0 6px 6px 6px; display: flex; flex-direction: column; gap: 4px; }

    #dialogue-box {
      background: var(--gb3); border: 3px solid var(--gb0); outline: 2px solid var(--gb1);
      padding: 12px 14px; min-height: 90px; max-height: 140px; overflow-y: auto;
      font-size: 10px; line-height: 1.9; color: var(--gb0);
    }
    #dialogue-box::-webkit-scrollbar { width: 6px; }
    #dialogue-box::-webkit-scrollbar-track { background: var(--gb2); }
    #dialogue-box::-webkit-scrollbar-thumb { background: var(--gb1); }
    #dialogue-text { white-space: pre-wrap; }

    .cursor-blink {
      display: inline-block; width: 8px; height: 10px;
      background: var(--gb0); animation: blink 0.7s steps(1) infinite;
      vertical-align: middle; margin-left: 2px;
    }
    @keyframes blink { 50% { opacity: 0; } }

    #choices { display: flex; gap: 4px; }
    .choice-btn {
      flex: 1; background: var(--gb3); border: 3px solid var(--gb0); outline: 2px solid var(--gb1);
      padding: 10px 10px 10px 20px;
      font-family: 'Press Start 2P', monospace; font-size: 8px; line-height: 1.5;
      color: var(--gb0); cursor: pointer; text-align: left;
      transition: background 0.1s; position: relative; pointer-events: auto;
    }
    .choice-btn::before {
      content: '▶'; position: absolute; left: 6px; top: 50%;
      transform: translateY(-50%); opacity: 0; color: var(--gb0); font-size: 7px;
    }
    .choice-btn:hover, .choice-btn:focus { background: var(--gb2); }
    .choice-btn:hover::before, .choice-btn:focus::before { opacity: 1; }
    .choice-btn:disabled { opacity: 0.3; cursor: not-allowed; pointer-events: none; }

    #play-again { display: none; pointer-events: auto; }
    #play-again button {
      width: 100%; background: var(--gb3); border: 3px solid var(--gb0); outline: 2px solid var(--gb1);
      padding: 12px; font-family: 'Press Start 2P', monospace; font-size: 10px;
      color: var(--gb0); cursor: pointer; text-align: center; letter-spacing: 2px;
    }
    #play-again button:hover { background: var(--gb2); }

    #onboarding-overlay {
      position: absolute; inset: 0; background: var(--gb0); z-index: 100;
      display: flex; align-items: center; justify-content: center; pointer-events: auto;
    }
    #onboarding-box { max-width: 420px; width: 90%; display: flex; flex-direction: column; gap: 10px; }
    #onboarding-box h1 { font-size: 18px; color: var(--gb3); letter-spacing: 6px; text-align: center; margin-bottom: 2px; }
    #onboarding-box p { font-size: 7px; color: var(--gb2); line-height: 2; text-align: center; }
    .ob-field { display: flex; flex-direction: column; gap: 3px; }
    .ob-field label { font-size: 7px; color: var(--gb2); letter-spacing: 1px; text-transform: uppercase; }
    .ob-field select, .ob-field input {
      padding: 10px; background: var(--gb3); border: 2px solid var(--gb1);
      color: var(--gb0); font-family: 'Press Start 2P', monospace; font-size: 9px; outline: none;
    }
    .ob-field input::placeholder { color: var(--gb1); }
    .ob-field input:focus, .ob-field select:focus { border-color: var(--gb0); outline: 1px solid var(--gb0); }
    #start-btn {
      margin-top: 4px; padding: 14px; background: var(--gb3);
      border: 3px solid var(--gb0); outline: 2px solid var(--gb1);
      color: var(--gb0); font-family: 'Press Start 2P', monospace;
      font-size: 9px; cursor: pointer; letter-spacing: 2px;
    }
    #start-btn:hover { background: var(--gb2); }

    #stat-overlay {
      position: absolute; inset: 0; background: rgba(15,56,15,0.94); z-index: 50;
      display: none; align-items: center; justify-content: center; pointer-events: auto;
    }
    #stat-card {
      background: var(--gb3); border: 3px solid var(--gb0); outline: 2px solid var(--gb1);
      padding: 16px; max-width: 340px; width: 85%;
    }
    #stat-card h2 { font-size: 10px; color: var(--gb0); margin-bottom: 12px; text-align: center; letter-spacing: 2px; }
    .stat-row { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
    .stat-label { font-size: 6px; color: var(--gb0); width: 65px; text-transform: uppercase; }
    .stat-bar-bg { flex: 1; height: 6px; background: var(--gb2); border: 1px solid var(--gb1); overflow: hidden; }
    .stat-bar-fill { height: 100%; background: var(--gb0); transition: width 0.5s ease; }
    .stat-val { font-size: 6px; color: var(--gb0); width: 26px; text-align: right; }
    #stat-close {
      margin-top: 12px; width: 100%; padding: 8px;
      background: var(--gb2); border: 2px solid var(--gb1);
      color: var(--gb0); font-family: 'Press Start 2P', monospace; font-size: 7px; cursor: pointer;
    }
    #stat-close:hover { background: var(--gb3); }
    #stat-toggle {
      position: absolute; top: 4px; left: 50%; transform: translateX(-50%);
      z-index: 25; background: var(--gb0); border: 1px solid var(--gb1);
      padding: 2px 8px; font-family: 'Press Start 2P', monospace;
      font-size: 6px; color: var(--gb2); cursor: pointer; pointer-events: auto;
    }
    #stat-toggle:hover { color: var(--gb3); border-color: var(--gb3); }
    #snd-toggle {
      position: absolute; top: 4px; left: calc(50% + 44px);
      z-index: 25; background: var(--gb0); border: 1px solid var(--gb1);
      padding: 2px 8px; font-family: 'Press Start 2P', monospace;
      font-size: 6px; color: var(--gb2); cursor: pointer; pointer-events: auto;
    }
    #snd-toggle:hover { color: var(--gb3); border-color: var(--gb3); }

    #loading-overlay {
      position: absolute; inset: 0; background: rgba(15,56,15,0.85);
      z-index: 200; display: none; align-items: center; justify-content: center;
      flex-direction: column; gap: 10px; pointer-events: auto;
    }
    .lds-ring { width: 28px; height: 28px; position: relative; }
    .lds-ring div {
      width: 22px; height: 22px; border: 3px solid var(--gb3);
      border-color: var(--gb3) transparent transparent transparent;
      border-radius: 50%; position: absolute;
      animation: lds-ring 1s cubic-bezier(0.5,0,0.5,1) infinite;
    }
    @keyframes lds-ring { to { transform: rotate(360deg); } }
    #loading-text { font-size: 8px; color: var(--gb2); }

    #transition-overlay {
      position: absolute; inset: 0; background: var(--gb0); z-index: 150;
      display: none; align-items: center; justify-content: center; opacity: 0; pointer-events: none;
    }
    #transition-text { font-size: 12px; color: var(--gb3); letter-spacing: 3px; }

    #error-bar {
      position: absolute; bottom: 0; left: 0; right: 0;
      background: var(--gb0); border-top: 2px solid var(--gb3);
      padding: 6px 10px; font-size: 7px; color: var(--gb3); z-index: 300; display: none; pointer-events: auto;
    }
    #error-bar a { color: var(--gb3); cursor: pointer; text-decoration: underline; }

    @media (max-width: 640px) {
      #game-wrapper { border-width: 2px; aspect-ratio: auto; height: 100vh; max-height: 100vh; }
      #hud { padding: 4px 6px; }
      #hud-age { font-size: 10px; }
      #dialogue-box { font-size: 8px; min-height: 70px; max-height: 110px; padding: 8px 10px; }
      .choice-btn { font-size: 7px; padding: 8px 8px 8px 16px; }
      .rel-chip { font-size: 5.5px; min-width: 80px; }
      .rel-icon { width: 22px; height: 22px; }
      .rel-chip .rel-name { font-size: 5.5px; }
      .rel-chip .rel-role { font-size: 4.5px; }
      #onboarding-box h1 { font-size: 14px; }
    }
    @media (max-height: 500px) { #dialogue-box { min-height: 50px; max-height: 80px; } }
  </style>
</head>
<body>
<div id="game-wrapper">
  <div id="phaser-canvas"></div>
  <div id="ui-overlay">
    <div id="hud"><div id="hud-age">AGE 0</div><div id="hud-meta"></div></div>
    <button id="stat-toggle">STATS</button>
    <button id="snd-toggle">♪ ON</button>
    <div id="hud-relations"></div>
    <div id="dialogue-area">
      <div id="dialogue-box"><span id="dialogue-text"></span><span class="cursor-blink"></span></div>
      <div id="choices">
        <button class="choice-btn" id="btn-a" disabled>A</button>
        <button class="choice-btn" id="btn-b" disabled>B</button>
      </div>
      <div id="play-again"><button>PLAY AGAIN</button></div>
    </div>
  </div>
  <div id="onboarding-overlay">
    <div id="onboarding-box">
      <h1>DREAMLAND</h1>
      <p>A life simulator. Enter your starting conditions, then navigate key moments through choices.</p>
      <div class="ob-field"><label>Gender</label><select id="gender"><option value="female">Female</option><option value="male">Male</option></select></div>
      <div class="ob-field"><label>City of birth</label><input id="city" placeholder="e.g. Chicago" /></div>
      <div class="ob-field"><label>I want to become…</label><input id="desire" placeholder="e.g. famous / rich / a musician" /></div>
      <button id="start-btn">START LIFE</button>
    </div>
  </div>
  <div id="stat-overlay">
    <div id="stat-card"><h2>TRAINER CARD</h2><div id="stat-bars"></div><button id="stat-close">CLOSE [ESC]</button></div>
  </div>
  <div id="loading-overlay"><div class="lds-ring"><div></div></div><div id="loading-text">Generating life moment…</div></div>
  <div id="transition-overlay"><div id="transition-text"></div></div>
  <div id="error-bar"></div>
</div>

<script>
const API_BASE = "https://life-sim-production.up.railway.app";

// Game Boy 4 shades
const GB = { BLACK: 0x0f380f, DARK: 0x306230, LIGHT: 0x8bac0f, WHITE: 0x9bbc0f };
const P = 2; // base pixel unit

function getSceneType(age, stats) {
  if (age <= 5)  return 'nursery';
  if (age <= 12) return 'school';
  if (age <= 18) return 'bedroom';
  if (age <= 25) return 'apartment';
  if (age <= 55) {
    if (stats.health < 0.2) return 'hospital';
    return stats.money > 0.6 ? 'home' : 'office';
  }
  if (stats.health < 0.3) return 'hospital';
  return 'home';
}

// ── Drawing helpers ──
function fillDither(gfx, x, y, w, h, c1, c2, pat) {
  const ps = 2;
  gfx.fillStyle(c1, 1); gfx.fillRect(x, y, w, h);
  gfx.fillStyle(c2, 1);
  for (let py = 0; py < h; py += ps) {
    for (let px = 0; px < w; px += ps) {
      const gx = Math.floor(px/ps), gy = Math.floor(py/ps);
      let draw = false;
      if (pat === 'check') draw = (gx+gy)%2===0;
      else if (pat === 'horiz') draw = gy%2===0;
      else if (pat === 'vert') draw = gx%2===0;
      else if (pat === 'sparse') draw = gx%4===0 && gy%4===0;
      else if (pat === 'dense') draw = (gx+gy)%2===0 || gx%3===0;
      if (draw) gfx.fillRect(x+px, y+py, ps, ps);
    }
  }
}

// Sprite map renderer: 0=BLACK 1=DARK 2=LIGHT 3=WHITE .=transparent
function drawSprite(gfx, map, ox, oy, s) {
  const rows = map.trim().split('\n');
  for (let r = 0; r < rows.length; r++) {
    const row = rows[r];
    for (let c = 0; c < row.length; c++) {
      const ch = row[c];
      if (ch === '.' || ch === ' ') continue;
      const shade = ch==='0'?GB.BLACK:ch==='1'?GB.DARK:ch==='2'?GB.LIGHT:GB.WHITE;
      gfx.fillStyle(shade, 1);
      gfx.fillRect(ox + c*s, oy + r*s, s, s);
    }
  }
}

// Draw a filled rounded rect (pixel art approximation)
function pxRect(g, x, y, w, h, color) {
  g.fillStyle(color, 1);
  g.fillRect(x, y, w, h);
}
function pxBorder(g, x, y, w, h, color, t=2) {
  g.fillStyle(color, 1);
  g.fillRect(x, y, w, t);       // top
  g.fillRect(x, y+h-t, w, t);   // bottom
  g.fillRect(x, y, t, h);       // left
  g.fillRect(x+w-t, y, t, h);   // right
}

// ═══════════════════════════════════════════════
// PHASER SCENE — Detailed Game Boy rooms
// ═══════════════════════════════════════════════
class LifeScene extends Phaser.Scene {
  constructor() { super({ key: 'LifeScene' }); }

  create() {
    this.particles = [];
    this.renderScene('nursery', {money:.5,stability:.5,status:.5,health:.5,stress:.5,freedom:.5,exposure:.5}, 0);
    this.time.addEvent({ delay: 80, callback: () => this.tickParticles(), loop: true });
  }

  renderScene(type, stats, age) {
    this.children.removeAll(true); this.tweens.killAll(); this.particles = [];
    const W = this.cameras.main.width, H = this.cameras.main.height;
    const floorY = Math.floor(H * 0.64);
    const wallTop = Math.floor(H * 0.06);
    const ceilH = 12;

    // ── BG ──
    const bg = this.add.graphics();
    pxRect(bg, 0, 0, W, H, GB.WHITE);

    // ── Ceiling with molding ──
    const ceil = this.add.graphics();
    pxRect(ceil, 0, wallTop, W, ceilH, GB.DARK);
    pxRect(ceil, 0, wallTop, W, P, GB.BLACK);
    pxRect(ceil, 0, wallTop+ceilH-P, W, P, GB.BLACK);
    // Crown molding detail
    pxRect(ceil, 0, wallTop+ceilH, W, 4, GB.LIGHT);
    pxRect(ceil, 0, wallTop+ceilH+4, W, P, GB.DARK);

    // ── Wall with texture ──
    const wall = this.add.graphics();
    pxRect(wall, 0, wallTop+ceilH+5, W, floorY-wallTop-ceilH-5, GB.WHITE);
    // Subtle wallpaper stripe pattern
    wall.fillStyle(GB.LIGHT, 1);
    for (let y = wallTop+ceilH+5; y < floorY-12; y += 16) {
      wall.fillRect(0, y, W, P);
    }
    // Wainscoting / lower wall panel
    const panelTop = floorY - 52;
    pxRect(wall, 0, panelTop, W, P, GB.DARK);
    // Panel rectangles
    wall.fillStyle(GB.LIGHT, 0.5);
    for (let x = 20; x < W-40; x += 120) {
      pxBorder(wall, x, panelTop+6, 100, 34, GB.LIGHT, P);
    }

    // ── Baseboard ──
    pxRect(wall, 0, floorY-12, W, 12, GB.DARK);
    pxRect(wall, 0, floorY-12, W, P, GB.BLACK);
    pxRect(wall, 0, floorY-6, W, P, GB.BLACK);
    pxRect(wall, 0, floorY-P, W, P, GB.BLACK);

    // ── Floor ──
    const fl = this.add.graphics();
    if (type === 'hospital') {
      pxRect(fl, 0, floorY, W, H-floorY, GB.WHITE);
      fillDither(fl, 0, floorY, W, H-floorY, GB.WHITE, GB.LIGHT, 'check');
      fl.fillStyle(GB.DARK, 0.6);
      for (let x = 0; x < W; x += 48) fl.fillRect(x, floorY, P, H-floorY);
      for (let y = floorY; y < H; y += 48) fl.fillRect(0, y, W, P);
    } else if (type === 'school') {
      pxRect(fl, 0, floorY, W, H-floorY, GB.LIGHT);
      fl.fillStyle(GB.DARK, 1);
      for (let y = floorY; y < H; y += 14) fl.fillRect(0, y, W, P);
      for (let y = floorY; y < H; y += 14) {
        const off = (Math.floor((y-floorY)/14)%2)*60;
        for (let x = off; x < W; x += 120) fl.fillRect(x, y, P, 14);
      }
    } else {
      // Wood plank floor
      pxRect(fl, 0, floorY, W, H-floorY, GB.LIGHT);
      fl.fillStyle(GB.DARK, 1);
      for (let y = floorY; y < H; y += 18) {
        fl.fillRect(0, y, W, P);
        const off = (Math.floor((y-floorY)/18)%2)*80;
        for (let x = off; x < W; x += 160) fl.fillRect(x, y, P, 18);
      }
      // Grain details
      fl.fillStyle(GB.DARK, 0.3);
      for (let y = floorY+4; y < H; y += 18) {
        for (let x = 10; x < W; x += 40) {
          fl.fillRect(x, y, 12, P);
        }
      }
    }
    pxRect(fl, 0, floorY, W, P, GB.BLACK);

    // ── Window ──
    this.drawWindow(Math.floor(W*0.06), wallTop+22, 100, 130, age, type);

    // ── Room contents ──
    this.drawRoom(type, stats, age, W, H, floorY);

    // ── Character ──
    this.drawChar(age, stats, Math.floor(W*0.38), floorY);

    // ── Particles ──
    this.spawnParticles(type, stats, W, H, floorY);

    // ── Death overlay ──
    if (type === 'death') {
      const d = this.add.graphics();
      fillDither(d, 0, 0, W, H, GB.BLACK, GB.DARK, 'check');
      d.setAlpha(0.55);
    }
  }

  // ══════════════════════════════════════
  // Window — large, detailed
  // ══════════════════════════════════════
  drawWindow(x, y, w, h, age, type) {
    const g = this.add.graphics();
    // Outer frame shadow
    pxRect(g, x-2, y-2, w+4, h+4, GB.BLACK);
    // Frame
    pxRect(g, x, y, w, h, GB.DARK);
    // Inner frame
    pxRect(g, x+6, y+6, w-12, h-12, GB.BLACK);

    const night = ((age*7+10)%24) < 6 || ((age*7+10)%24) > 20;
    pxRect(g, x+8, y+8, w-16, h-16, night ? GB.BLACK : GB.WHITE);

    if (night) {
      g.fillStyle(GB.LIGHT, 1);
      // Stars
      const stars = [[12,10],[28,18],[52,8],[70,22],[18,50],[44,38],[66,56],[30,72],[56,68],[14,84],[48,90],[72,44],[38,16],[62,82]];
      stars.forEach(([sx,sy]) => {
        if (sx < w-20 && sy < h-20) g.fillRect(x+8+sx, y+8+sy, P, P);
      });
      // Moon - larger crescent
      g.fillStyle(GB.LIGHT, 1);
      for (let dy = 0; dy < 18; dy++) {
        for (let dx = 0; dx < 18; dx++) {
          const cx = dx-9, cy = dy-9;
          if (cx*cx+cy*cy <= 81 && !((cx-4)*(cx-4)+cy*cy <= 49)) {
            g.fillRect(x+w-34+dx*P, y+14+dy*P, P, P);
          }
        }
      }
    } else {
      // Clouds
      g.fillStyle(GB.LIGHT, 1);
      // Cloud 1
      g.fillRect(x+16, y+24, 30, 8); g.fillRect(x+20, y+18, 22, 6);
      g.fillRect(x+28, y+14, 10, 4);
      // Cloud 2
      g.fillRect(x+54, y+44, 24, 6); g.fillRect(x+58, y+38, 14, 6);
      // Sun hints
      g.fillStyle(GB.WHITE, 1);
      g.fillRect(x+w-36, y+16, 16, 16);
      g.fillStyle(GB.LIGHT, 1);
      g.fillRect(x+w-40, y+22, 4, 4);
      g.fillRect(x+w-18, y+22, 4, 4);
      g.fillRect(x+w-30, y+12, 4, 4);
      g.fillRect(x+w-30, y+34, 4, 4);
    }

    // Crossbars - thick
    g.fillStyle(GB.DARK, 1);
    g.fillRect(x+8+Math.floor((w-16)/2)-3, y+6, 6, h-12);
    g.fillRect(x+6, y+8+Math.floor((h-16)/2)-3, w-12, 6);
    // Crossbar inner
    g.fillStyle(GB.BLACK, 1);
    g.fillRect(x+8+Math.floor((w-16)/2)-1, y+8, 2, h-16);
    g.fillRect(x+8, y+8+Math.floor((h-16)/2)-1, w-16, 2);

    // Sill
    pxRect(g, x-8, y+h+2, w+16, 10, GB.DARK);
    pxRect(g, x-8, y+h+2, w+16, P, GB.BLACK);
    pxRect(g, x-8, y+h+10, w+16, P, GB.BLACK);
    // Sill bracket details
    pxRect(g, x+6, y+h+12, 6, 8, GB.DARK);
    pxRect(g, x+w-12, y+h+12, 6, 8, GB.DARK);

    // Light beam on floor
    if (!night && type !== 'hospital' && type !== 'death') {
      const gl = this.add.graphics();
      // Angled light trapezoid
      gl.fillStyle(GB.WHITE, 1);
      gl.beginPath();
      gl.moveTo(x-4, y+h+60);
      gl.lineTo(x+w+20, y+h+60);
      gl.lineTo(x+w+40, y+h+120);
      gl.lineTo(x-20, y+h+120);
      gl.closePath();
      gl.fill();
      fillDither(gl, x-20, y+h+60, w+60, 60, GB.WHITE, GB.LIGHT, 'sparse');
      gl.setAlpha(0.3);
    }

    // Curtains
    const cg = this.add.graphics();
    // Left curtain
    pxRect(cg, x+8, y+6, 14, h-10, GB.DARK);
    cg.fillStyle(GB.BLACK, 1);
    for (let cy = y+10; cy < y+h-8; cy += 8) {
      cg.fillRect(x+8, cy, P, 4);
      cg.fillRect(x+14, cy+4, P, 4);
    }
    // Right curtain
    pxRect(cg, x+w-22, y+6, 14, h-10, GB.DARK);
    cg.fillStyle(GB.BLACK, 1);
    for (let cy = y+10; cy < y+h-8; cy += 8) {
      cg.fillRect(x+w-10, cy, P, 4);
      cg.fillRect(x+w-16, cy+4, P, 4);
    }
    // Curtain rod
    pxRect(cg, x-4, y+2, w+8, 4, GB.BLACK);
    // Rod finials
    pxRect(cg, x-8, y, 6, 8, GB.BLACK);
    pxRect(cg, x+w+2, y, 6, 8, GB.BLACK);
  }

  // ══════════════════════════════════════
  // Room furniture — LARGE detailed GB art
  // ══════════════════════════════════════
  drawRoom(type, stats, age, W, H, floorY) {
    const g = this.add.graphics();

    switch(type) {
      case 'nursery': {
        // ── LARGE Crib ──
        const cx = Math.floor(W*0.52), cw = 200, ch = 140;
        const cTop = floorY - ch;
        // Crib body
        pxRect(g, cx, cTop, cw, ch, GB.LIGHT);
        pxBorder(g, cx, cTop, cw, ch, GB.BLACK, 3);
        // Inner rail panels
        pxRect(g, cx+3, cTop+3, cw-6, ch-3, GB.LIGHT);
        // Slats - detailed with shadow
        g.fillStyle(GB.DARK, 1);
        for (let i = 0; i < 14; i++) {
          const sx = cx + 12 + i * 13;
          g.fillRect(sx, cTop+6, 4, ch-44);
          g.fillStyle(GB.BLACK, 1);
          g.fillRect(sx+4, cTop+8, P, ch-48);
          g.fillStyle(GB.DARK, 1);
        }
        // Top rail
        pxRect(g, cx, cTop, cw, 8, GB.DARK);
        pxRect(g, cx, cTop, cw, P, GB.BLACK);
        pxRect(g, cx, cTop+6, cw, P, GB.BLACK);
        // Bottom rail
        pxRect(g, cx+3, floorY-40, cw-6, 4, GB.BLACK);
        // Mattress
        pxRect(g, cx+10, floorY-38, cw-20, 30, GB.WHITE);
        pxBorder(g, cx+10, floorY-38, cw-20, 30, GB.DARK, P);
        // Mattress quilting
        g.fillStyle(GB.LIGHT, 1);
        for (let mx = cx+20; mx < cx+cw-24; mx += 24) {
          g.fillRect(mx, floorY-30, P, 14);
        }
        // Pillow
        pxRect(g, cx+16, floorY-46, 44, 12, GB.WHITE);
        pxBorder(g, cx+16, floorY-46, 44, 12, GB.LIGHT, P);
        // Corner posts with knobs
        pxRect(g, cx-6, cTop-20, 14, ch+20, GB.BLACK);
        pxRect(g, cx+cw-8, cTop-20, 14, ch+20, GB.BLACK);
        pxRect(g, cx-4, cTop-18, 10, 6, GB.DARK); // left knob
        pxRect(g, cx+cw-6, cTop-18, 10, 6, GB.DARK); // right knob
        // Round tops
        pxRect(g, cx-2, cTop-24, 6, 6, GB.DARK);
        pxRect(g, cx+cw-4, cTop-24, 6, 6, GB.DARK);
        // Crib legs
        pxRect(g, cx+4, floorY-6, 8, 6, GB.BLACK);
        pxRect(g, cx+cw-12, floorY-6, 8, 6, GB.BLACK);

        // ── Large Teddy Bear ──
        drawSprite(g, `
.....0000.....
....001100....
...00011000...
..0001001000..
.00013001300.
.00010001000.
.00010101000.
..0001110000.
...00000000..
....011110...
...01111110..
..0111111110.
..0111111110.
.01111111110.
.01111111110.
..0111111110.
..0111001110.
...011..110..
...011..110..
...000..000..`, Math.floor(W*0.25), floorY-62, 3);

        // ── Mobile from ceiling (larger) ──
        const mobX = cx + cw/2;
        pxRect(g, mobX-1, 0, P, cTop-16, GB.BLACK);
        // Crossbar
        pxRect(g, mobX-40, cTop-22, 80, 4, GB.DARK);
        pxRect(g, mobX-40, cTop-22, 80, P, GB.BLACK);
        // Hanging shapes
        const shapes = [
          {dx:-32, dy:-8, type:'star'},
          {dx:0, dy:-14, type:'moon'},
          {dx:28, dy:-6, type:'star'}
        ];
        shapes.forEach(s => {
          pxRect(g, mobX+s.dx, cTop+s.dy, P, Math.abs(s.dy)+6, GB.BLACK);
          if (s.type === 'star') {
            drawSprite(g, `
..00..
.0110.
011110
.0110.
..00..`, mobX+s.dx-5, cTop+s.dy+Math.abs(s.dy)+6, P);
          } else {
            drawSprite(g, `
.000.
01110
01110
.010.
.000.`, mobX+s.dx-4, cTop+s.dy+Math.abs(s.dy)+6, P);
          }
        });

        // ── Rug ──
        const rugX = Math.floor(W*0.22), rugW = 200, rugH = 32;
        fillDither(g, rugX, floorY+6, rugW, rugH, GB.DARK, GB.LIGHT, 'horiz');
        pxBorder(g, rugX, floorY+6, rugW, rugH, GB.BLACK, P);
        // Rug fringe
        g.fillStyle(GB.DARK, 1);
        for (let fx = rugX+4; fx < rugX+rugW-4; fx += 6) {
          g.fillRect(fx, floorY+6+rugH, 2, 6);
        }
        break;
      }

      case 'school': {
        // ── LARGE Blackboard ──
        const bx = Math.floor(W*0.22), by = H*0.10, bw = 320, bh = 160;
        // Frame
        pxRect(g, bx-8, by-8, bw+16, bh+16, GB.DARK);
        pxBorder(g, bx-8, by-8, bw+16, bh+16, GB.BLACK, 3);
        // Inner frame bevel
        pxRect(g, bx-3, by-3, bw+6, bh+6, GB.BLACK);
        // Board surface
        pxRect(g, bx, by, bw, bh, GB.BLACK);
        // Chalk text: "HELLO CLASS" in large pixel font
        drawSprite(g, `
0.0..0000.0....0.....000.
0.0..0....0....0....0...0
000..000..0....0....0...0
0.0..0....0....0....0...0
0.0..0000.0000.0000..000.`, bx+20, by+16, 3);
        // Math underneath
        drawSprite(g, `
.33..33..33..33.333.
33...33.33..33..33..
.33..3333...33..333.
..33.33.33..33....33
33...33..33.3333.333`, bx+20, by+64, 2);
        // Chalk lines (notes)
        g.fillStyle(GB.LIGHT, 0.7);
        g.fillRect(bx+20, by+100, 120, P);
        g.fillRect(bx+20, by+110, 80, P);
        g.fillRect(bx+20, by+120, 140, P);
        g.fillRect(bx+20, by+130, 60, P);
        g.fillRect(bx+180, by+100, 100, P);
        g.fillRect(bx+180, by+110, 70, P);
        // Chalk tray
        pxRect(g, bx-8, by+bh+8, bw+16, 10, GB.DARK);
        pxRect(g, bx-8, by+bh+8, bw+16, P, GB.BLACK);
        // Chalk pieces
        pxRect(g, bx+20, by+bh+10, 16, 4, GB.LIGHT);
        pxRect(g, bx+44, by+bh+10, 12, 4, GB.WHITE);
        pxRect(g, bx+64, by+bh+10, 8, 4, GB.LIGHT);
        // Eraser
        pxRect(g, bx+bw-40, by+bh+9, 24, 6, GB.DARK);
        pxRect(g, bx+bw-40, by+bh+9, 24, P, GB.BLACK);

        // ── Student desk + chair (larger) ──
        const dx = Math.floor(W*0.62), dy = floorY;
        // Desk top
        pxRect(g, dx, dy-68, 180, 10, GB.DARK);
        pxRect(g, dx, dy-68, 180, P, GB.BLACK);
        pxRect(g, dx, dy-60, 180, P, GB.BLACK);
        // Desk front panel
        pxRect(g, dx+8, dy-58, 164, 24, GB.DARK);
        pxBorder(g, dx+8, dy-58, 164, 24, GB.BLACK, P);
        // Desk legs
        pxRect(g, dx+8, dy-34, 6, 34, GB.BLACK);
        pxRect(g, dx+166, dy-34, 6, 34, GB.BLACK);
        // Cross brace
        pxRect(g, dx+14, dy-18, 152, P, GB.BLACK);

        // Books on desk
        pxRect(g, dx+20, dy-88, 50, 20, GB.BLACK);
        pxRect(g, dx+22, dy-86, 14, 16, GB.DARK);
        pxRect(g, dx+38, dy-88, 14, 18, GB.LIGHT);
        pxRect(g, dx+54, dy-84, 14, 14, GB.DARK);
        // Book spines
        g.fillStyle(GB.LIGHT, 1);
        g.fillRect(dx+36, dy-86, P, 16);
        g.fillRect(dx+52, dy-86, P, 14);

        // Pencil
        pxRect(g, dx+100, dy-76, 40, 3, GB.BLACK);
        pxRect(g, dx+100, dy-76, 6, 3, GB.DARK); // eraser end
        pxRect(g, dx+138, dy-75, 4, P, GB.LIGHT); // tip

        // Apple on desk
        drawSprite(g, `
..0..
.010.
01110
11111
11111
01110
.111.`, dx+150, dy-88, 2);

        // Chair
        pxRect(g, dx+50, dy-42, 70, 6, GB.DARK); // seat
        pxRect(g, dx+50, dy-42, 70, P, GB.BLACK);
        pxRect(g, dx+54, dy-36, 6, 36, GB.BLACK); // front legs
        pxRect(g, dx+110, dy-36, 6, 36, GB.BLACK);
        // Chair back
        pxRect(g, dx+108, dy-90, 8, 54, GB.BLACK);
        pxRect(g, dx+96, dy-92, 24, 6, GB.DARK);
        pxRect(g, dx+96, dy-92, 24, P, GB.BLACK);
        pxRect(g, dx+96, dy-74, 24, 4, GB.DARK);

        // ── Wall clock (larger) ──
        const clx = Math.floor(W*0.88), cly = H*0.10;
        pxRect(g, clx, cly, 48, 48, GB.DARK);
        pxBorder(g, clx, cly, 48, 48, GB.BLACK, 3);
        pxRect(g, clx+6, cly+6, 36, 36, GB.LIGHT);
        pxBorder(g, clx+6, cly+6, 36, 36, GB.BLACK, P);
        // Hour markers
        g.fillStyle(GB.BLACK, 1);
        [[23,8],[36,12],[40,23],[36,34],[23,38],[10,34],[6,23],[10,12]].forEach(([mx,my])=>{
          g.fillRect(clx+mx, cly+my, 3, 3);
        });
        // Hands
        g.fillRect(clx+23, cly+10, P, 14); // minute
        g.fillRect(clx+23, cly+23, 10, P); // hour
        g.fillRect(clx+23, cly+23, 3, 3); // center
        break;
      }

      case 'bedroom': {
        // ── LARGE Bed ──
        const bx = Math.floor(W*0.50), by = floorY;
        const bedW = 240, bedH = 80;
        // Bed frame
        pxRect(g, bx, by-bedH, bedW, bedH, GB.DARK);
        pxBorder(g, bx, by-bedH, bedW, bedH, GB.BLACK, 3);
        // Mattress
        pxRect(g, bx+6, by-bedH+6, bedW-12, bedH-12, GB.WHITE);
        // Blanket
        fillDither(g, bx+6, by-bedH+20, bedW-12, bedH-28, GB.LIGHT, GB.DARK, 'horiz');
        pxRect(g, bx+6, by-bedH+20, bedW-12, 4, GB.DARK);
        // Pillow
        pxRect(g, bx+12, by-bedH+8, 60, 18, GB.WHITE);
        pxBorder(g, bx+12, by-bedH+8, 60, 18, GB.LIGHT, P);
        pxRect(g, bx+14, by-bedH+12, 4, 10, GB.LIGHT); // pillow crease
        // Second pillow
        pxRect(g, bx+78, by-bedH+10, 50, 16, GB.WHITE);
        pxBorder(g, bx+78, by-bedH+10, 50, 16, GB.LIGHT, P);
        // Headboard - tall, detailed
        pxRect(g, bx-6, by-bedH-60, bedW+12, 64, GB.DARK);
        pxBorder(g, bx-6, by-bedH-60, bedW+12, 64, GB.BLACK, 3);
        // Headboard panels
        pxBorder(g, bx+10, by-bedH-52, 60, 44, GB.BLACK, P);
        pxBorder(g, bx+80, by-bedH-52, 80, 44, GB.BLACK, P);
        pxBorder(g, bx+170, by-bedH-52, 60, 44, GB.BLACK, P);
        // Headboard top detail
        pxRect(g, bx-6, by-bedH-64, bedW+12, 6, GB.BLACK);
        // Legs
        pxRect(g, bx+4, by-6, 8, 6, GB.BLACK);
        pxRect(g, bx+bedW-12, by-6, 8, 6, GB.BLACK);

        // ── Large Poster ──
        const px2 = Math.floor(W*0.16), py2 = H*0.11;
        pxRect(g, px2-3, py2-3, 86, 110, GB.BLACK);
        pxRect(g, px2, py2, 80, 104, GB.DARK);
        // Poster art - skull/band
        drawSprite(g, `
....0000....
...001100...
..00100100..
.0010000100.
.0011001100.
..00111100..
...011110...
..01111110..
.0111111110.
0111111111110
.0110110110.
..010.010..
...01.10...`, px2+14, py2+8, 4);
        // Band name
        g.fillStyle(GB.LIGHT, 1);
        g.fillRect(px2+10, py2+72, 60, 3);
        g.fillRect(px2+18, py2+80, 44, 3);
        g.fillRect(px2+14, py2+88, 52, 3);

        // ── Desk with lamp ──
        const dx = Math.floor(W*0.14), dy = floorY;
        // Desk
        pxRect(g, dx, dy-60, 110, 8, GB.DARK);
        pxRect(g, dx, dy-60, 110, P, GB.BLACK);
        pxRect(g, dx, dy-54, 110, P, GB.BLACK);
        pxRect(g, dx+6, dy-52, 6, 52, GB.BLACK);
        pxRect(g, dx+98, dy-52, 6, 52, GB.BLACK);
        // Drawer
        pxRect(g, dx+60, dy-52, 42, 26, GB.DARK);
        pxBorder(g, dx+60, dy-52, 42, 26, GB.BLACK, P);
        pxRect(g, dx+76, dy-42, 10, P, GB.LIGHT); // handle

        // Lamp (taller)
        pxRect(g, dx+20, dy-100, 30, 16, GB.BLACK); // shade
        g.fillStyle(GB.DARK, 1);
        g.fillRect(dx+22, dy-98, 26, 12); // shade inner
        pxRect(g, dx+33, dy-84, 4, 22, GB.BLACK); // stem
        pxRect(g, dx+26, dy-64, 18, 4, GB.BLACK); // base
        // Glow
        const gl = this.add.graphics();
        fillDither(gl, dx+4, dy-108, 60, 50, GB.WHITE, GB.LIGHT, 'sparse');
        gl.setAlpha(0.2);

        // ── Shoes by bed ──
        drawSprite(g, `
.000..000.
01110.1110
01110.1110
.000..000.`, bx+40, by-10, 2);
        break;
      }

      case 'apartment': {
        const nice = stats.money > 0.5;
        // ── LARGE Couch ──
        const sx = Math.floor(W*0.46), sy = floorY;
        const couchW = 260, couchH = 110;
        // Back
        pxRect(g, sx, sy-couchH, couchW, 36, GB.DARK);
        pxBorder(g, sx, sy-couchH, couchW, 36, GB.BLACK, 3);
        // Seat
        pxRect(g, sx+3, sy-couchH+36, couchW-6, 50, nice?GB.DARK:GB.BLACK);
        if (nice) {
          // Cushions
          pxRect(g, sx+10, sy-couchH+40, 74, 40, GB.LIGHT);
          pxBorder(g, sx+10, sy-couchH+40, 74, 40, GB.DARK, P);
          pxRect(g, sx+90, sy-couchH+40, 74, 40, GB.LIGHT);
          pxBorder(g, sx+90, sy-couchH+40, 74, 40, GB.DARK, P);
          pxRect(g, sx+170, sy-couchH+40, 80, 40, GB.LIGHT);
          pxBorder(g, sx+170, sy-couchH+40, 80, 40, GB.DARK, P);
          // Cushion creases
          g.fillStyle(GB.DARK, 1);
          [sx+46, sx+126, sx+210].forEach(cx => {
            g.fillRect(cx, sy-couchH+48, P, 24);
          });
        }
        // Armrests
        pxRect(g, sx-14, sy-couchH+10, 18, couchH-18, GB.BLACK);
        pxRect(g, sx+couchW-4, sy-couchH+10, 18, couchH-18, GB.BLACK);
        pxRect(g, sx-12, sy-couchH+12, 14, 10, GB.DARK);
        pxRect(g, sx+couchW-2, sy-couchH+12, 14, 10, GB.DARK);
        // Front panel
        pxRect(g, sx+3, sy-24, couchW-6, 16, GB.BLACK);
        // Legs
        pxRect(g, sx+8, sy-8, 8, 8, GB.BLACK);
        pxRect(g, sx+couchW-16, sy-8, 8, 8, GB.BLACK);

        // ── Coffee table (larger) ──
        const tx = Math.floor(W*0.26);
        pxRect(g, tx, sy-42, 120, 8, GB.DARK);
        pxRect(g, tx, sy-42, 120, P, GB.BLACK);
        pxRect(g, tx, sy-36, 120, P, GB.BLACK);
        pxRect(g, tx+8, sy-34, 6, 34, GB.BLACK);
        pxRect(g, tx+106, sy-34, 6, 34, GB.BLACK);
        // Shelf under
        pxRect(g, tx+12, sy-18, 96, 4, GB.DARK);
        // Mug (larger)
        pxRect(g, tx+40, sy-60, 18, 18, GB.BLACK);
        pxRect(g, tx+42, sy-58, 14, 14, GB.LIGHT);
        pxRect(g, tx+58, sy-56, 6, 10, GB.BLACK); // handle
        pxRect(g, tx+60, sy-54, 2, 6, GB.LIGHT);
        // Steam
        g.fillStyle(GB.DARK, 0.6);
        g.fillRect(tx+46, sy-68, P, 6);
        g.fillRect(tx+50, sy-72, P, 8);
        g.fillRect(tx+54, sy-66, P, 4);
        // Magazine
        pxRect(g, tx+70, sy-52, 30, 8, GB.BLACK);
        pxRect(g, tx+72, sy-50, 26, 4, GB.LIGHT);

        // ── Wall art (larger) ──
        const fx = Math.floor(W*0.56), fy = H*0.10;
        pxRect(g, fx-4, fy-4, 94, 68, GB.BLACK);
        pxRect(g, fx, fy, 86, 60, GB.LIGHT);
        // Landscape painting
        pxRect(g, fx+4, fy+34, 78, 22, GB.DARK);
        // Mountains
        g.fillStyle(GB.BLACK, 1);
        for (let i = 0; i < 40; i++) {
          const mh = Math.sin(i*0.15)*18 + Math.sin(i*0.3)*8;
          g.fillRect(fx+4+i*2, fy+34-Math.max(0,mh), 2, Math.max(0,mh));
        }
        // Sun in painting
        pxRect(g, fx+62, fy+8, 12, 12, GB.WHITE);

        if (nice) {
          // ── Floor lamp ──
          const lx = Math.floor(W*0.84);
          pxRect(g, lx+2, sy-180, P, 130, GB.BLACK); // pole
          // Shade
          pxRect(g, lx-12, sy-186, 30, 20, GB.DARK);
          pxBorder(g, lx-12, sy-186, 30, 20, GB.BLACK, P);
          pxRect(g, lx-10, sy-184, 26, 16, GB.LIGHT);
          // Base
          pxRect(g, lx-10, sy-50, 24, 6, GB.BLACK);
          pxRect(g, lx-6, sy-44, 16, 44, GB.BLACK);
          // Glow
          const lg = this.add.graphics();
          fillDither(lg, lx-20, sy-186, 46, 50, GB.WHITE, GB.LIGHT, 'sparse');
          lg.setAlpha(0.15);
        }

        // ── Rug ──
        fillDither(g, Math.floor(W*0.24), floorY+6, 240, 36, GB.DARK, GB.LIGHT, 'horiz');
        pxBorder(g, Math.floor(W*0.24), floorY+6, 240, 36, GB.BLACK, P);
        break;
      }

      case 'office': {
        // ── LARGE Desk ──
        const dx = Math.floor(W*0.36), dy = floorY;
        const deskW = 280, deskH = 12;
        pxRect(g, dx, dy-76, deskW, deskH, GB.DARK);
        pxRect(g, dx, dy-76, deskW, P, GB.BLACK);
        pxRect(g, dx, dy-66, deskW, P, GB.BLACK);
        // Desk legs
        pxRect(g, dx+8, dy-64, 8, 64, GB.BLACK);
        pxRect(g, dx+deskW-16, dy-64, 8, 64, GB.BLACK);
        // Drawer unit
        pxRect(g, dx+deskW-90, dy-64, 80, 50, GB.DARK);
        pxBorder(g, dx+deskW-90, dy-64, 80, 50, GB.BLACK, P);
        // Individual drawers
        pxBorder(g, dx+deskW-86, dy-60, 72, 14, GB.BLACK, P);
        pxBorder(g, dx+deskW-86, dy-44, 72, 14, GB.BLACK, P);
        pxRect(g, dx+deskW-56, dy-54, 16, P, GB.LIGHT); // handle
        pxRect(g, dx+deskW-56, dy-38, 16, P, GB.LIGHT); // handle
        // Cross brace
        pxRect(g, dx+16, dy-24, deskW-112, P, GB.BLACK);

        // ── Monitor (large) ──
        const mx = dx + 60;
        pxRect(g, mx, dy-152, 120, 76, GB.BLACK);
        pxBorder(g, mx, dy-152, 120, 76, GB.BLACK, 4);
        pxRect(g, mx+6, dy-148, 108, 64, GB.LIGHT);
        // Screen content - code
        g.fillStyle(GB.DARK, 1);
        const lines = [40,60,30,50,70,20,55,35,45,65];
        lines.forEach((lw,i) => {
          g.fillRect(mx+12, dy-142+i*6, lw, P);
        });
        // Blinking cursor
        pxRect(g, mx+12+lines[lines.length-1]+4, dy-142+(lines.length-1)*6, 4, 4, GB.BLACK);
        // Monitor stand
        pxRect(g, mx+44, dy-76, 32, 10, GB.BLACK);
        pxRect(g, mx+36, dy-68, 48, 4, GB.DARK);
        pxRect(g, mx+36, dy-68, 48, P, GB.BLACK);

        // ── Keyboard ──
        pxRect(g, mx-10, dy-84, 80, 10, GB.BLACK);
        pxRect(g, mx-8, dy-82, 76, 6, GB.DARK);
        // Key rows
        g.fillStyle(GB.LIGHT, 1);
        for (let row = 0; row < 2; row++) {
          for (let k = 0; k < 12; k++) {
            g.fillRect(mx-6+k*6, dy-80+row*3, 4, P);
          }
        }

        // ── Mouse ──
        pxRect(g, mx+78, dy-82, 12, 8, GB.BLACK);
        pxRect(g, mx+80, dy-80, 8, 4, GB.DARK);

        // ── Office chair (large, detailed) ──
        const chx = dx + 100;
        // Seat
        pxRect(g, chx, dy-50, 80, 10, GB.DARK);
        pxBorder(g, chx, dy-50, 80, 10, GB.BLACK, P);
        // Back
        pxRect(g, chx+60, dy-110, 16, 64, GB.BLACK);
        pxRect(g, chx+56, dy-114, 24, 8, GB.DARK);
        pxBorder(g, chx+56, dy-114, 24, 8, GB.BLACK, P);
        pxRect(g, chx+56, dy-82, 24, 6, GB.DARK);
        // Center pole
        pxRect(g, chx+36, dy-40, 6, 28, GB.BLACK);
        // Wheels
        pxRect(g, chx+22, dy-12, 34, 6, GB.BLACK);
        pxRect(g, chx+20, dy-6, 8, 6, GB.BLACK);
        pxRect(g, chx+50, dy-6, 8, 6, GB.BLACK);

        // ── Filing cabinet (large) ──
        const fc = Math.floor(W*0.82);
        pxRect(g, fc, dy-160, 70, 160, GB.DARK);
        pxBorder(g, fc, dy-160, 70, 160, GB.BLACK, 3);
        // 3 drawers
        for (let d = 0; d < 3; d++) {
          const ddy = dy-156+d*50;
          pxBorder(g, fc+8, ddy, 54, 42, GB.BLACK, P);
          pxRect(g, fc+28, ddy+18, 14, 3, GB.LIGHT); // handle
        }
        // Label slots
        g.fillStyle(GB.LIGHT, 1);
        for (let d = 0; d < 3; d++) {
          g.fillRect(fc+30, dy-156+d*50+6, 10, 8);
        }

        // ── Wall clock ──
        const clx = Math.floor(W*0.18), cly = H*0.12;
        pxRect(g, clx, cly, 48, 48, GB.DARK);
        pxBorder(g, clx, cly, 48, 48, GB.BLACK, 3);
        pxRect(g, clx+6, cly+6, 36, 36, GB.LIGHT);
        pxBorder(g, clx+6, cly+6, 36, 36, GB.BLACK, P);
        g.fillStyle(GB.BLACK, 1);
        g.fillRect(clx+23, cly+10, P, 14);
        g.fillRect(clx+23, cly+23, 10, P);
        g.fillRect(clx+23, cly+23, 3, 3);
        break;
      }

      case 'home': {
        const nice = stats.money > 0.5;
        // ── LARGE Sofa ──
        const sx = Math.floor(W*0.42), sy = floorY;
        const sofaW = 280, sofaH = 120;
        // Back
        pxRect(g, sx, sy-sofaH, sofaW, 40, GB.DARK);
        pxBorder(g, sx, sy-sofaH, sofaW, 40, GB.BLACK, 3);
        // Seat area
        pxRect(g, sx+3, sy-sofaH+40, sofaW-6, 54, GB.DARK);
        // Cushions
        pxRect(g, sx+10, sy-sofaH+44, 82, 44, GB.LIGHT);
        pxBorder(g, sx+10, sy-sofaH+44, 82, 44, GB.DARK, P);
        pxRect(g, sx+98, sy-sofaH+44, 82, 44, GB.LIGHT);
        pxBorder(g, sx+98, sy-sofaH+44, 82, 44, GB.DARK, P);
        pxRect(g, sx+186, sy-sofaH+44, 82, 44, GB.LIGHT);
        pxBorder(g, sx+186, sy-sofaH+44, 82, 44, GB.DARK, P);
        // Throw pillows
        drawSprite(g, `
.0000.
011110
111111
111111
011110
.0000.`, sx+16, sy-sofaH+16, 3);
        drawSprite(g, `
.1111.
100001
100001
.1111.`, sx+sofaW-60, sy-sofaH+20, 3);
        // Armrests
        pxRect(g, sx-16, sy-sofaH+14, 20, sofaH-22, GB.BLACK);
        pxRect(g, sx+sofaW-4, sy-sofaH+14, 20, sofaH-22, GB.BLACK);
        pxRect(g, sx-14, sy-sofaH+16, 16, 14, GB.DARK);
        pxRect(g, sx+sofaW-2, sy-sofaH+16, 16, 14, GB.DARK);
        // Front
        pxRect(g, sx+3, sy-26, sofaW-6, 18, GB.BLACK);
        // Legs
        pxRect(g, sx+10, sy-8, 10, 8, GB.BLACK);
        pxRect(g, sx+sofaW-20, sy-8, 10, 8, GB.BLACK);

        // ── Coffee table ──
        const tx = Math.floor(W*0.26);
        pxRect(g, tx, sy-44, 120, 8, GB.DARK);
        pxRect(g, tx, sy-44, 120, P, GB.BLACK);
        pxRect(g, tx, sy-38, 120, P, GB.BLACK);
        pxRect(g, tx+8, sy-36, 6, 36, GB.BLACK);
        pxRect(g, tx+106, sy-36, 6, 36, GB.BLACK);
        // Books on table
        pxRect(g, tx+20, sy-58, 36, 14, GB.BLACK);
        pxRect(g, tx+22, sy-56, 10, 10, GB.DARK);
        pxRect(g, tx+34, sy-58, 10, 12, GB.LIGHT);
        pxRect(g, tx+46, sy-54, 8, 8, GB.DARK);
        // Remote
        pxRect(g, tx+70, sy-52, 20, 8, GB.BLACK);
        pxRect(g, tx+72, sy-50, 4, P, GB.LIGHT);
        pxRect(g, tx+78, sy-50, 4, P, GB.LIGHT);

        // ── LARGE Bookshelf ──
        const bkx = Math.floor(W*0.80), bky = H*0.08;
        const bkW = 90, bkH = floorY - bky;
        pxRect(g, bkx, bky, bkW, bkH, GB.DARK);
        pxBorder(g, bkx, bky, bkW, bkH, GB.BLACK, 3);
        // 5 shelves with books
        for (let s = 0; s < 5; s++) {
          const shY = bky + 8 + s * Math.floor((bkH-16)/5);
          pxRect(g, bkx+3, shY, bkW-6, 4, GB.BLACK);
          // Books - varied sizes
          for (let b = 0; b < 6; b++) {
            const bw = 6 + (b%3)*3;
            const bh = 20 + (b*7)%16;
            const bc = b%3===0?GB.BLACK:b%3===1?GB.DARK:GB.LIGHT;
            pxRect(g, bkx+6+b*13, shY-bh, bw, bh, bc);
            // Spine detail
            g.fillStyle(bc===GB.BLACK?GB.DARK:GB.BLACK, 1);
            g.fillRect(bkx+7+b*13, shY-bh+2, P, bh-4);
          }
        }

        if (nice) {
          // ── Family photo (larger) ──
          const fpx = Math.floor(W*0.20), fpy = H*0.12;
          pxRect(g, fpx-4, fpy-4, 80, 64, GB.BLACK);
          pxRect(g, fpx, fpy, 72, 56, GB.LIGHT);
          // Family portrait
          drawSprite(g, `
..00.....00..
..01.....01..
.0110...0110.
.0100...0010.
..01.....10..
..011...110..
..0111.1110..
...01...10...
...01...10...
..01.0.0.10..
..00.000.00..
.....010.....
.....010.....
.....000.....`, fpx+16, fpy+6, 3);
        }

        // ── Rug ──
        fillDither(g, Math.floor(W*0.24), floorY+6, 260, 38, GB.DARK, GB.LIGHT, 'horiz');
        pxBorder(g, Math.floor(W*0.24), floorY+6, 260, 38, GB.BLACK, P);
        // Rug pattern
        g.fillStyle(GB.BLACK, 1);
        g.fillRect(Math.floor(W*0.24)+8, floorY+14, 244, P);
        g.fillRect(Math.floor(W*0.24)+8, floorY+36, 244, P);
        break;
      }

      case 'hospital': {
        // ── LARGE Hospital bed ──
        const bx = Math.floor(W*0.24), by = floorY;
        const bedW = 300, bedH = 80;
        // Frame
        pxRect(g, bx, by-bedH, bedW, bedH, GB.DARK);
        pxBorder(g, bx, by-bedH, bedW, bedH, GB.BLACK, 3);
        // Mattress
        pxRect(g, bx+8, by-bedH+8, bedW-16, bedH-14, GB.WHITE);
        // Blanket
        fillDither(g, bx+60, by-bedH+14, bedW-76, bedH-26, GB.LIGHT, GB.DARK, 'horiz');
        pxRect(g, bx+60, by-bedH+14, bedW-76, 4, GB.DARK);
        // Pillow
        pxRect(g, bx+14, by-bedH+10, 54, 22, GB.WHITE);
        pxBorder(g, bx+14, by-bedH+10, 54, 22, GB.LIGHT, P);
        // Headboard
        pxRect(g, bx-8, by-bedH-50, 14, bedH+50, GB.BLACK);
        pxRect(g, bx-8, by-bedH-50, 80, 8, GB.DARK);
        pxBorder(g, bx-8, by-bedH-50, 80, 8, GB.BLACK, P);
        // Side rails
        pxRect(g, bx+4, by-bedH-30, P, 30, GB.BLACK);
        pxRect(g, bx+10, by-bedH-30, P, 30, GB.BLACK);
        pxRect(g, bx+4, by-bedH-32, 8, 4, GB.DARK);
        // Wheels
        const wheels = [bx+8, bx+bedW-16];
        wheels.forEach(wx => {
          pxRect(g, wx, by-4, 12, 4, GB.BLACK);
          // Wheel detail
          pxRect(g, wx+2, by, 8, 4, GB.DARK);
        });

        // ── IV Stand (tall, detailed) ──
        const ix = Math.floor(W*0.72);
        pxRect(g, ix+3, by-240, 4, 240, GB.BLACK);
        // Crossbar top
        pxRect(g, ix-12, by-242, 30, 4, GB.BLACK);
        pxRect(g, ix-12, by-242, 4, 8, GB.BLACK);
        pxRect(g, ix+14, by-242, 4, 8, GB.BLACK);
        // IV Bag
        pxRect(g, ix-6, by-234, 16, 30, GB.DARK);
        pxBorder(g, ix-6, by-234, 16, 30, GB.BLACK, P);
        pxRect(g, ix-4, by-232, 12, 26, GB.LIGHT);
        // Drip line
        g.fillStyle(GB.BLACK, 1);
        g.fillRect(ix+2, by-204, P, 100);
        // Drip chamber
        pxRect(g, ix-1, by-206, 6, 12, GB.BLACK);
        pxRect(g, ix, by-204, 4, 8, GB.LIGHT);
        // Base (tripod)
        pxRect(g, ix-14, by-10, 32, 4, GB.BLACK);
        pxRect(g, ix-18, by-6, 6, 6, GB.BLACK);
        pxRect(g, ix+16, by-6, 6, 6, GB.BLACK);
        pxRect(g, ix+1, by-6, 6, 6, GB.BLACK);

        // ── Heart monitor (large, detailed) ──
        const hmx = Math.floor(W*0.80), hmy = by-180;
        pxRect(g, hmx, hmy, 100, 72, GB.BLACK);
        pxBorder(g, hmx, hmy, 100, 72, GB.BLACK, 4);
        pxRect(g, hmx+6, hmy+6, 88, 44, GB.DARK);
        // EKG waveform
        const ekg = [0,0,0,0,0,-2,-4,-8,14,-6,0,0,0,0,0,0,-2,-4,-8,14,-6,0,0,0,0,0,0,0,0,-2,-4,10,-4,0,0,0,0,0,0,0];
        g.fillStyle(GB.LIGHT, 1);
        for (let i = 0; i < ekg.length-1; i++) {
          const y1 = hmy+28+ekg[i], y2 = hmy+28+ekg[i+1];
          g.fillRect(hmx+8+i*2, Math.min(y1,y2), P, Math.abs(y2-y1)+P);
        }
        // Readings
        g.fillStyle(GB.LIGHT, 1);
        g.fillRect(hmx+10, hmy+54, 24, 3);
        g.fillRect(hmx+40, hmy+54, 16, 3);
        g.fillRect(hmx+62, hmy+54, 30, 3);
        g.fillRect(hmx+10, hmy+62, 18, 3);
        // Monitor stand
        pxRect(g, hmx-4, hmy+72, 108, 6, GB.DARK);
        pxRect(g, hmx-4, hmy+72, 108, P, GB.BLACK);
        pxRect(g, hmx+6, hmy+78, 6, by-hmy-78, GB.BLACK);
        pxRect(g, hmx+88, hmy+78, 6, by-hmy-78, GB.BLACK);

        // ── Clipboard at foot ──
        pxRect(g, bx+bedW-8, by-100, 20, 32, GB.DARK);
        pxBorder(g, bx+bedW-8, by-100, 20, 32, GB.BLACK, P);
        pxRect(g, bx+bedW-4, by-96, 12, 24, GB.LIGHT);
        g.fillStyle(GB.BLACK, 1);
        g.fillRect(bx+bedW, by-92, 6, P);
        g.fillRect(bx+bedW, by-86, 6, P);
        g.fillRect(bx+bedW, by-80, 4, P);
        // Clip at top
        pxRect(g, bx+bedW-4, by-102, 12, 6, GB.BLACK);
        break;
      }
    }
  }

  // ══════════════════════════════════════
  // Character sprites — LARGE, detailed
  // ══════════════════════════════════════
  drawChar(age, stats, x, floorY) {
    const gfx = this.add.graphics();
    let map, scale;

    if (age <= 3) {
      // Baby - round, chubby proportions
      scale = 4;
      map = `
.....0000.....
....000000....
...00000000...
..0003003000..
..0003003000..
..0000000000..
..0000110000..
...00000000...
....000000....
.....0000.....
....111111....
...11111111...
...11111111...
...11111111...
....11..11....
....00..00....`;
    } else if (age <= 8) {
      // Child - slightly taller, big head
      scale = 4;
      map = `
....11111.....
...1111111....
..111111111...
..111111111...
..110030031...
..111000011...
..111011011...
...11111111...
....111111....
.....0000.....
....111111....
...11111111...
..1111111111..
..1111111111..
...11....11...
...11....11...
...11....11...
...00....00...`;
    } else if (age <= 14) {
      // Teen - taller, thinner
      scale = 4;
      map = `
....1111......
...111111.....
..11111111....
..11111111....
..11003003....
..11100001....
..11100101....
...11111111...
....111111....
.....1111.....
.....0000.....
....111111....
...11111111...
..1111111111..
..1111111111..
..1111111111..
...111..111...
...111..111...
...111..111...
...111..111...
...000..000...`;
    } else if (age <= 55) {
      // Adult - broad shoulders, full body
      scale = 5;
      map = `
...11111...
..1111111..
.111111111.
.110030031.
.111000011.
.111001011.
..1111111..
...11111...
...00000...
..1111111..
.111111111.
1111111111.
1111111111.
.111111111.
..11...11..
..11...11..
..11...11..
..00...00..`;
    } else {
      // Elderly - slightly hunched, lighter tones
      scale = 5;
      map = `
...22222...
..2222222..
.222222222.
.220030032.
.222000022.
.222001022.
..2222222..
...22222...
...00000...
..2222222..
.222222222.
2222222222.
2222222222.
.222222222.
..22...22..
..22...22..
..22...22..
..00...00..`;
    }

    const rows = map.trim().split('\n');
    const sprH = rows.length * scale;
    const sprW = rows[0].length * scale;
    const ox = x - sprW/2;
    const oy = floorY - sprH;

    drawSprite(gfx, map, ox, oy, scale);

    // Shadow (larger)
    const sh = this.add.graphics();
    fillDither(sh, ox-4, floorY+2, sprW+8, 10, GB.DARK, GB.LIGHT, 'check');
    sh.setAlpha(0.3);

    // Idle bob
    this.tweens.add({
      targets: gfx, y: -3,
      duration: 1600, yoyo: true, repeat: -1, ease: 'Sine.easeInOut'
    });
  }

  // ── Particles ──
  spawnParticles(type, stats, W, H, floorY) {
    if (type === 'death') return;
    // Dust motes
    for (let i = 0; i < 5; i++) {
      const p = this.add.graphics();
      p.fillStyle(GB.DARK, Phaser.Math.FloatBetween(0.15, 0.35));
      p.fillRect(0, 0, 3, 3);
      p.x = Phaser.Math.Between(0, W);
      p.y = Phaser.Math.Between(floorY*0.3, floorY*0.8);
      this.particles.push({ gfx:p, vx:Phaser.Math.FloatBetween(-0.12,0.12), vy:Phaser.Math.FloatBetween(0.04,0.12), maxY:floorY-10, wrap:false });
    }
    if (stats.stress > 0.7) {
      for (let i = 0; i < 12; i++) {
        const r = this.add.graphics();
        r.fillStyle(GB.DARK, 0.5);
        r.fillRect(0, 0, P, 6);
        r.x = Phaser.Math.Between(0, W);
        r.y = Phaser.Math.Between(-20, H);
        this.particles.push({ gfx:r, vx:-0.4, vy:3.5, maxY:H+10, wrap:true });
      }
    }
  }

  tickParticles() {
    const W = this.cameras.main.width;
    for (const p of this.particles) {
      p.gfx.x += p.vx; p.gfx.y += p.vy;
      if (p.gfx.y > p.maxY) { p.gfx.y = -10; if (p.wrap) p.gfx.x = Phaser.Math.Between(0, W); }
      if (p.gfx.x < -10) p.gfx.x = W+10;
      if (p.gfx.x > W+10) p.gfx.x = -10;
    }
  }
}

// ═══════════════════════════════════════════════
// Game State + API
// ═══════════════════════════════════════════════

// ── GB Sound Engine (Web Audio API chiptune) ──
const SFX = (() => {
  let ctx = null;
  let muted = false;
  const vol = 0.15; // master volume (gentle)

  function ensure() {
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (ctx.state === 'suspended') ctx.resume();
    return ctx;
  }

  function osc(type, freq, start, dur, v=vol, detune=0) {
    const c = ensure();
    const o = c.createOscillator();
    const g = c.createGain();
    o.type = type;
    o.frequency.value = freq;
    if (detune) o.detune.value = detune;
    g.gain.setValueAtTime(v, c.currentTime + start);
    g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + start + dur);
    o.connect(g); g.connect(c.destination);
    o.start(c.currentTime + start);
    o.stop(c.currentTime + start + dur + 0.05);
  }

  function noise(start, dur, v=vol*0.4) {
    const c = ensure();
    const bufSize = c.sampleRate * dur;
    const buf = c.createBuffer(1, bufSize, c.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
    const src = c.createBufferSource();
    src.buffer = buf;
    const g = c.createGain();
    g.gain.setValueAtTime(v, c.currentTime + start);
    g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + start + dur);
    src.connect(g); g.connect(c.destination);
    src.start(c.currentTime + start);
    src.stop(c.currentTime + start + dur + 0.05);
  }

  return {
    get muted() { return muted; },
    toggle() { muted = !muted; return muted; },

    // UI click — short square blip (Game Boy menu select)
    click() {
      if (muted) return;
      osc('square', 880, 0, 0.06, vol*0.6);
    },

    // Choice confirm — two ascending square notes
    confirm() {
      if (muted) return;
      osc('square', 523, 0, 0.08, vol*0.7);
      osc('square', 784, 0.08, 0.12, vol*0.7);
    },

    // Typewriter tick — tiny high click (very quiet, rapid)
    tick() {
      if (muted) return;
      osc('square', 1200, 0, 0.015, vol*0.15);
    },

    // Transition whoosh — descending sweep + noise
    transition() {
      if (muted) return;
      osc('square', 440, 0, 0.12, vol*0.5);
      osc('square', 330, 0.06, 0.12, vol*0.4);
      osc('square', 220, 0.12, 0.15, vol*0.3);
      noise(0, 0.25, vol*0.15);
    },

    // New turn arrival — bright ascending arpeggio (Pokémon encounter feel)
    newTurn() {
      if (muted) return;
      osc('square', 392, 0, 0.09, vol*0.5);     // G4
      osc('square', 494, 0.08, 0.09, vol*0.5);   // B4
      osc('square', 587, 0.16, 0.09, vol*0.5);   // D5
      osc('square', 784, 0.24, 0.14, vol*0.6);   // G5
    },

    // Game start — triumphant little fanfare
    start() {
      if (muted) return;
      osc('square', 523, 0, 0.1, vol*0.6);       // C5
      osc('square', 659, 0.1, 0.1, vol*0.6);     // E5
      osc('square', 784, 0.2, 0.1, vol*0.6);     // G5
      osc('square', 1047, 0.3, 0.2, vol*0.7);    // C6
      // harmony
      osc('square', 392, 0.3, 0.2, vol*0.3);     // G4
    },

    // Death — somber descending tone + low rumble
    death() {
      if (muted) return;
      osc('triangle', 392, 0, 0.3, vol*0.6);     // G4
      osc('triangle', 330, 0.25, 0.3, vol*0.5);   // E4
      osc('triangle', 262, 0.5, 0.3, vol*0.5);    // C4
      osc('triangle', 196, 0.75, 0.6, vol*0.5);   // G3
      // low rumble
      osc('sawtooth', 65, 0.7, 0.8, vol*0.15);
      noise(0.8, 0.5, vol*0.08);
    },

    // Stat up — quick happy chirp
    statUp() {
      if (muted) return;
      osc('square', 660, 0, 0.06, vol*0.4);
      osc('square', 880, 0.06, 0.1, vol*0.5);
    },

    // Error — buzzy low tone
    error() {
      if (muted) return;
      osc('square', 150, 0, 0.12, vol*0.5);
      osc('square', 120, 0.1, 0.15, vol*0.4);
    },

    // Play again — hopeful restart jingle
    playAgain() {
      if (muted) return;
      osc('square', 262, 0, 0.1, vol*0.5);       // C4
      osc('square', 330, 0.12, 0.1, vol*0.5);     // E4
      osc('square', 392, 0.24, 0.1, vol*0.5);     // G4
      osc('square', 523, 0.36, 0.18, vol*0.6);    // C5
      osc('square', 659, 0.5, 0.25, vol*0.5);     // E5
    },
  };
})();

function newRunId() {
  if (window.crypto?.randomUUID) return crypto.randomUUID();
  return Date.now()+'-'+Math.random().toString(16).slice(2);
}
function getSessionId() {
  let id = localStorage.getItem('lifeSimSessionId');
  if (!id) { id = newRunId(); localStorage.setItem('lifeSimSessionId', id); }
  return id;
}

const state = {
  session_id: getSessionId(), run_id: newRunId(), age: 0,
  gender:'unspecified', city:'', desire:'',
  stats: { money:.5,stability:.5,status:.5,health:.5,stress:.5,freedom:.5,exposure:.5 },
  relationships: [], history: []
};

let currentScenario = null, locked = false, phaserGame = null, lastFailedAction = null;

const $ = id => document.getElementById(id);
const el = {
  hudAge:$('hud-age'), hudMeta:$('hud-meta'), hudRelations:$('hud-relations'),
  dialogueText:$('dialogue-text'), dialogueBox:$('dialogue-box'),
  btnA:$('btn-a'), btnB:$('btn-b'), playAgain:$('play-again'),
  onboarding:$('onboarding-overlay'), startBtn:$('start-btn'),
  gender:$('gender'), city:$('city'), desire:$('desire'),
  statOverlay:$('stat-overlay'), statBars:$('stat-bars'),
  statClose:$('stat-close'), statToggle:$('stat-toggle'), sndToggle:$('snd-toggle'),
  loading:$('loading-overlay'), loadingText:$('loading-text'),
  transition:$('transition-overlay'), transitionText:$('transition-text'),
  errorBar:$('error-bar'),
};

const loadLines = ['Generating life moment…','Calculating consequences…','Locking the timeline…','Spooling the next decade…','Loading the moment…'];
let loadTimer = null;

function setLoading(on) {
  locked = on;
  if (on) { el.loading.style.display='flex'; let i=0; el.loadingText.textContent=loadLines[i]; loadTimer=setInterval(()=>{i=(i+1)%loadLines.length;el.loadingText.textContent=loadLines[i];},400); }
  else { el.loading.style.display='none'; if(loadTimer)clearInterval(loadTimer); }
}
function setError(msg) {
  if(!msg){el.errorBar.style.display='none';return;}
  el.errorBar.innerHTML=msg; el.errorBar.style.display='block';
  setTimeout(()=>{el.errorBar.style.display='none';},8000);
}
function setButtonsDisabled(d){el.btnA.disabled=d;el.btnB.disabled=d;}

function playTransition(text) {
  SFX.transition();
  return new Promise(resolve => {
    el.transition.style.display='flex'; el.transitionText.textContent=text; el.transition.style.opacity='0';
    let op=0;
    const fi=setInterval(()=>{op+=0.05;el.transition.style.opacity=String(Math.min(op,1));if(op>=1){clearInterval(fi);setTimeout(()=>{const fo=setInterval(()=>{op-=0.04;el.transition.style.opacity=String(Math.max(op,0));if(op<=0){clearInterval(fo);el.transition.style.display='none';resolve();}},30);},800);}},30);
  });
}
function sleep(ms){return new Promise(r=>setTimeout(r,ms));}

async function typewriter(text,speed=18){
  setButtonsDisabled(true);
  const cursor=el.dialogueBox.querySelector('.cursor-blink');
  el.dialogueText.textContent='';
  if(cursor)cursor.style.display='inline-block';
  for(let i=0;i<text.length;i++){el.dialogueText.textContent+=text[i];if(i%3===0)SFX.tick();el.dialogueBox.scrollTop=el.dialogueBox.scrollHeight;await sleep(speed);}
  setButtonsDisabled(false);
}
function showTextInstant(text){el.dialogueText.textContent=text;el.dialogueBox.scrollTop=el.dialogueBox.scrollHeight;}

function renderRelations(rels) {
  el.hudRelations.innerHTML='';
  if(!rels?.length)return;

  // --- GB portrait sprite maps (14x14 grid, each char = shade) ---
  // 0=BLACK(#0f380f) 1=DARK(#306230) 2=LIGHT(#8bac0f) 3=WHITE(#9bbc0f) .=transparent
  const PORTRAITS = {
    // Mother / female caretaker — soft face, long hair
    mother: [
      '..011111110..',
      '.0111111111..',
      '01111111111..',
      '0113332233110',
      '.13333223311.',
      '.13302200311.',
      '.13333333311.',
      '.13330033311.',
      '.11333333110.',
      '..1113331100.',
      '...01111100..',
      '..011111110..',
      '.0111111111..',
      '.01111.1111..',
    ],
    // Father / male caretaker — square jaw, short hair
    father: [
      '..01111110...',
      '.0011111100..',
      '.0111111110..',
      '.0133332331..',
      '.1333323310..',
      '.1330220031..',
      '.1333333310..',
      '.1333003310..',
      '.1133333100..',
      '..113333100..',
      '...0111100...',
      '..01111110...',
      '..11111111...',
      '..1111.1111..',
    ],
    // Friend / peer — round face, messy hair
    friend: [
      '...101010....',
      '..01111110...',
      '.0111111110..',
      '.0133333310..',
      '.1333333310..',
      '.1302020031..',
      '.1333333310..',
      '.1333333310..',
      '.1133003110..',
      '..113333100..',
      '...011110....',
      '..01111110...',
      '..11111111...',
      '..111..111...',
    ],
    // Partner / lover — gentle features, styled hair
    partner: [
      '.011111110...',
      '01111111110..',
      '0111111111100',
      '0113333233110',
      '.13333323311.',
      '.13020200311.',
      '.13333333311.',
      '.13333333311.',
      '.11330033110.',
      '..113333100..',
      '...011110....',
      '..011111110..',
      '.0111111111..',
      '.0111..1111..',
    ],
    // Child / offspring — small round face, big eyes
    child: [
      '..0111110....',
      '.011111110...',
      '.011111110...',
      '.013333331...',
      '.133333331...',
      '.130200203...',
      '.133333331...',
      '.133303331...',
      '.113333311...',
      '..1133311....',
      '...01110.....',
      '..011111.....',
      '..0111110....',
      '..011.011....',
    ],
    // Boss / mentor — stern, glasses, broad
    mentor: [
      '..0111110....',
      '.011111110...',
      '.011111110...',
      '.013333331...',
      '.101001001...',
      '.130200203...',
      '.133333331...',
      '.133333331...',
      '.113300331...',
      '..1133311....',
      '...01110.....',
      '..0111111....',
      '.01111111....',
      '.0111.0111...',
    ],
    // Sibling — similar to friend but with a distinctive tuft
    sibling: [
      '....010......',
      '..01111110...',
      '.0111111110..',
      '.0133333310..',
      '.1333333310..',
      '.1302020031..',
      '.1333333310..',
      '.1333333310..',
      '.1130033110..',
      '..113333100..',
      '...011110....',
      '..01111110...',
      '..11111111...',
      '..111..111...',
    ],
    // Generic / fallback — neutral face
    generic: [
      '..0111110....',
      '.011111110...',
      '.011111110...',
      '.013333331...',
      '.133333331...',
      '.130200201...',
      '.133333331...',
      '.133333331...',
      '.113303331...',
      '..1133311....',
      '...01110.....',
      '..0111110....',
      '..1111111....',
      '..111..111...',
    ],
  };

  const GB = ['#0f380f','#306230','#8bac0f','#9bbc0f'];

  function pickPortrait(role) {
    const r = (role||'').toLowerCase();
    if (r.includes('mother') || r.includes('mom') || r.includes('mum') || r.includes('grandmother') || r.includes('grandma') || r.includes('aunt')) return PORTRAITS.mother;
    if (r.includes('father') || r.includes('dad') || r.includes('grandfather') || r.includes('grandpa') || r.includes('uncle')) return PORTRAITS.father;
    if (r.includes('partner') || r.includes('wife') || r.includes('husband') || r.includes('girlfriend') || r.includes('boyfriend') || r.includes('lover') || r.includes('spouse') || r.includes('fiancé') || r.includes('fiancee') || r.includes('fiance')) return PORTRAITS.partner;
    if (r.includes('son') || r.includes('daughter') || r.includes('baby') || r.includes('child') || r.includes('kid') || r.includes('toddler')) return PORTRAITS.child;
    if (r.includes('brother') || r.includes('sister') || r.includes('sibling') || r.includes('twin')) return PORTRAITS.sibling;
    if (r.includes('boss') || r.includes('mentor') || r.includes('teacher') || r.includes('coach') || r.includes('professor') || r.includes('manager')) return PORTRAITS.mentor;
    if (r.includes('friend') || r.includes('pal') || r.includes('buddy') || r.includes('roommate') || r.includes('classmate') || r.includes('colleague') || r.includes('neighbor')) return PORTRAITS.friend;
    return PORTRAITS.generic;
  }

  function drawPortrait(ctx, map, size) {
    const rows = map;
    const cols = rows[0].length;
    const px = size / Math.max(rows.length, cols);
    // Background
    ctx.fillStyle = GB[3];
    ctx.fillRect(0, 0, size, size);
    // Offset to center
    const ox = Math.floor((size - cols * px) / 2);
    const oy = Math.floor((size - rows.length * px) / 2);
    for (let r = 0; r < rows.length; r++) {
      for (let c = 0; c < rows[r].length; c++) {
        const ch = rows[r][c];
        if (ch === '.') continue;
        const shade = parseInt(ch);
        if (isNaN(shade)) continue;
        ctx.fillStyle = GB[shade];
        ctx.fillRect(ox + c * px, oy + r * px, px + 0.5, px + 0.5);
      }
    }
  }

  rels.forEach((r, i) => {
    if (!r?.name) return;
    const chip = document.createElement('div'); chip.className = 'rel-chip';

    const icon = document.createElement('canvas'); icon.className = 'rel-icon';
    icon.width = 28; icon.height = 28;
    const ctx = icon.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    const portrait = pickPortrait(r.role || '');
    drawPortrait(ctx, portrait, 28);

    const info = document.createElement('div');
    const nameEl = document.createElement('span'); nameEl.className = 'rel-name';
    nameEl.textContent = r.name || '???';
    const roleEl = document.createElement('span'); roleEl.className = 'rel-role';
    roleEl.textContent = (r.role || 'unknown').toUpperCase();
    info.appendChild(nameEl);
    info.appendChild(roleEl);

    chip.appendChild(icon);
    chip.appendChild(info);
    el.hudRelations.appendChild(chip);
  });
}

const STAT_KEYS=['money','stability','status','health','stress','freedom','exposure'];
function renderStatBars(){
  el.statBars.innerHTML='';
  STAT_KEYS.forEach(k=>{
    const val=Math.round((state.stats[k]||0.5)*100);
    const row=document.createElement('div'); row.className='stat-row';
    row.innerHTML=`<span class="stat-label">${k}</span><div class="stat-bar-bg"><div class="stat-bar-fill" style="width:${val}%"></div></div><span class="stat-val">${val}%</span>`;
    el.statBars.appendChild(row);
  });
}

function updateScene(isDeath=false){
  const scene=phaserGame?.scene?.scenes?.[0];
  if(!scene)return;
  scene.renderScene(isDeath?'death':getSceneType(state.age,state.stats),state.stats,state.age);
}

async function apiTurn(){const r=await fetch(API_BASE+'/api/turn',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({state})});const j=await r.json().catch(()=>null);if(!r.ok)throw new Error(j?.message||'turn_failed');return j;}
async function apiApply(effects){const r=await fetch(API_BASE+'/api/apply',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({age:state.age,stats:state.stats,effects,death_cause_hint:currentScenario?.death_cause_hint||''})});const j=await r.json().catch(()=>null);if(!r.ok)throw new Error(j?.error||'apply_failed');return j;}
async function apiEpilogue(cause){const r=await fetch(API_BASE+'/api/epilogue',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({age:state.age,gender:state.gender,city:state.city,desire:state.desire,relationships:state.relationships||[],history:state.history.slice(-30),cause})});const j=await r.json().catch(()=>null);if(!r.ok)throw new Error(j?.error||'epilogue_failed');return j;}
function logEvent(event,data={}){fetch(API_BASE+'/api/analytics',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({event,session_id:state.session_id,run_id:state.run_id,...data})}).catch(()=>{});}
function saveSession(){try{sessionStorage.setItem('dreamlandState',JSON.stringify({state:{...state},scenario:currentScenario,ts:Date.now()}));}catch{}}
function clearSave(){try{sessionStorage.removeItem('dreamlandState');}catch{}}
function restoreSession(){try{const raw=sessionStorage.getItem('dreamlandState');if(!raw)return false;const saved=JSON.parse(raw);if(Date.now()-saved.ts>2*60*60*1000){clearSave();return false;}Object.assign(state,saved.state);currentScenario=saved.scenario;return true;}catch{return false;}}

async function startGame(){
  setError('');
  state.run_id=newRunId();state.age=0;state.history=[];state.relationships=[];
  state.stats={money:.5,stability:.5,status:.5,health:.5,stress:.5,freedom:.5,exposure:.5};
  state.gender=(el.gender.value||'unspecified').trim();
  state.city=(el.city.value||'').trim();
  state.desire=(el.desire.value||'').trim();
  if(!state.city||!state.desire){setError('Enter a city and what you want to become.');return;}
  el.onboarding.style.display='none';
  el.hudMeta.textContent=`${state.city.toUpperCase()} · ${state.desire.toUpperCase()}`;
  el.playAgain.style.display='none';
  el.btnA.style.display='';el.btnB.style.display='';
  setLoading(true);setButtonsDisabled(true);
  try{
    const data=await apiTurn();
    if(data.birth_stats)state.stats=data.birth_stats;
    if(data.relationships?.length===3)state.relationships=data.relationships;
    state.age=data.age_to; currentScenario=data.scenario;
    el.hudAge.textContent=`AGE ${state.age}`;
    el.btnA.textContent=currentScenario.options[0].label;
    el.btnB.textContent=currentScenario.options[1].label;
    renderRelations(state.relationships);renderStatBars();updateScene();saveSession();
    logEvent('game_start',{city:state.city,desire:state.desire,gender:state.gender});
    setLoading(false);
    SFX.start();
    await typewriter(currentScenario.text,18);
  }catch(e){setLoading(false);lastFailedAction=startGame;setError(`Start failed: ${e.message} — <a onclick="retryLast()">RETRY</a>`);setButtonsDisabled(true);}
}

async function choose(index){
  if(locked||!currentScenario)return;
  SFX.confirm();
  setError('');setLoading(true);setButtonsDisabled(true);
  try{
    const chosen=currentScenario.options[index];
    state.history.push(chosen.label);
    logEvent('choice',{age:state.age,choice:index,label:chosen.label});
    const applied=await apiApply(chosen.effects||{});
    state.stats=applied.next_stats;
    if(applied.died){
      setLoading(false);
      const cause=(currentScenario.death_cause_hint||'complications').trim()||'complications';
      await playTransition(`AGE ${state.age}`);
      SFX.death();
      let endingText=`You die at ${state.age}. Cause: ${cause}.`;
      try{const ep=await apiEpilogue(cause);endingText=ep?.text||endingText;}catch{}
      el.hudAge.textContent=`RIP AGE ${state.age}`;
      el.btnA.style.display='none';el.btnB.style.display='none';
      updateScene(true);clearSave();
      logEvent('death',{age:state.age,cause});
      await typewriter(endingText,22);
      SFX.playAgain();
      el.playAgain.style.display='block';
      return;
    }
    const prevAge=state.age;
    const next=await apiTurn();
    if(next.relationships?.length===3)state.relationships=next.relationships;
    state.age=next.age_to;currentScenario=next.scenario;
    setLoading(false);
    const diff=state.age-prevAge;
    await playTransition(diff>0?`${diff} YEARS LATER...`:`AGE ${state.age}`);
    SFX.newTurn();
    el.hudAge.textContent=`AGE ${state.age}`;
    el.btnA.textContent=currentScenario.options[0].label;
    el.btnB.textContent=currentScenario.options[1].label;
    renderRelations(state.relationships);renderStatBars();updateScene();saveSession();
    await typewriter(currentScenario.text,18);
  }catch(e){SFX.error();setLoading(false);lastFailedAction=()=>choose(index);setError(`Turn failed: ${e.message} — <a onclick="retryLast()">RETRY</a>`);setButtonsDisabled(false);}
}

window.retryLast=function(){if(lastFailedAction)lastFailedAction();};

function resetGame(){
  currentScenario=null;locked=false;
  state.run_id=newRunId();state.age=0;state.history=[];state.relationships=[];
  state.stats={money:.5,stability:.5,status:.5,health:.5,stress:.5,freedom:.5,exposure:.5};
  el.hudAge.textContent='AGE 0';el.hudMeta.textContent='';
  el.hudRelations.innerHTML='';el.dialogueText.textContent='';
  el.btnA.textContent='A';el.btnB.textContent='B';
  el.btnA.style.display='';el.btnB.style.display='';
  setButtonsDisabled(true);el.playAgain.style.display='none';
  el.onboarding.style.display='flex';
  setError('');setLoading(false);clearSave();updateScene();
}

window.addEventListener('DOMContentLoaded',()=>{
  phaserGame=new Phaser.Game({
    type:Phaser.AUTO,parent:'phaser-canvas',
    width:960,height:600,backgroundColor:0x9bbc0f,
    scale:{mode:Phaser.Scale.FIT,autoCenter:Phaser.Scale.CENTER_BOTH},
    scene:[LifeScene],pixelArt:true,antialias:false,roundPixels:true,
  });
  el.startBtn.addEventListener('click',e=>{e.preventDefault();SFX.click();startGame();});
  el.btnA.addEventListener('click',()=>{SFX.click();choose(0);});
  el.btnB.addEventListener('click',()=>{SFX.click();choose(1);});
  el.playAgain.querySelector('button').addEventListener('click',resetGame);
  el.statToggle.addEventListener('click',()=>{SFX.click();renderStatBars();el.statOverlay.style.display='flex';});
  el.statClose.addEventListener('click',()=>{SFX.click();el.statOverlay.style.display='none';});
  el.sndToggle.addEventListener('click',()=>{
    const m=SFX.toggle();
    el.sndToggle.textContent=m?'♪ OFF':'♪ ON';
    if(!m)SFX.click();
  });
  document.addEventListener('keydown',e=>{
    if(e.key==='Escape')el.statOverlay.style.display='none';
    if(e.key==='m'||e.key==='M'){el.sndToggle.click();return;}
    if(el.onboarding.style.display!=='none')return;
    if(e.key==='1'||e.key==='a')el.btnA.click();
    if(e.key==='2'||e.key==='b')el.btnB.click();
    if(e.key==='s'||e.key==='S')el.statToggle.click();
  });
  if(restoreSession()){
    el.onboarding.style.display='none';
    el.hudAge.textContent=`AGE ${state.age}`;
    el.hudMeta.textContent=`${state.city.toUpperCase()} · ${state.desire.toUpperCase()}`;
    renderRelations(state.relationships);renderStatBars();updateScene();
    if(currentScenario){showTextInstant(currentScenario.text);el.btnA.textContent=currentScenario.options[0].label;el.btnB.textContent=currentScenario.options[1].label;setButtonsDisabled(false);}
  }
});
</script>
</body>
</html>
